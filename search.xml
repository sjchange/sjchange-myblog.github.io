<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码演示</title>
      <link href="/myblog/2023/01/09/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/myblog/2023/01/09/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的介绍"><a href="#JavaScript的介绍" class="headerlink" title="JavaScript的介绍"></a>JavaScript的介绍</h2><p>JavaScript最初由Netscape的Brendan Eich设计，最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java，但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。微软同时期也推出了JScript来迎战JavaScript的脚本语言。<br>发展初期，JavaScript的标准并未确定，同期有Netscape的JavaScript，微软的JScript和CEnvi的ScriptEase三足鼎立。为了互用性，Ecma国际（前身为欧洲计算机制造商协会）创建了ECMA-262标准（ECMAScript），两者都属于ECMAScript的实现，尽管JavaScript作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是JavaScript具有非常丰富的特性。 [10]  1997年，在ECMA（欧洲计算机制造商协会）的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型，浏览器对象模型。 [9]<br>JavaScript是甲骨文公司的注册商标。Ecma国际以JavaScript为基础制定了ECMAScript标准。JavaScript也可以用于其他场合，如服务器端编程（Node.js）。</p><h2 id="最基本的函数"><a href="#最基本的函数" class="headerlink" title="最基本的函数:"></a>最基本的函数:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>()) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础知识</title>
      <link href="/myblog/2023/01/09/Vue/Vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/myblog/2023/01/09/Vue/Vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="数据驱动视图"><a href="#数据驱动视图" class="headerlink" title="数据驱动视图"></a>数据驱动视图</h2><p>数据的变化会驱动视图自动更新</p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>再网页中 form表单负责采集数据 ajax 负责提交数据<br>js数据的变化 会被自动渲染到页面上<br>页面上的表单采集的数据发生变化时 会被vue自动获取 并更新到js数据中<br>数据驱动视图和双向数据绑定的底层原理时mvvm(Mode数据源 View视图 ViewModel就是vue的实例)</p><h2 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h2><p>v-text 指令的缺点 会覆盖元素内部原有的内容</p><h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><p>实际开发中用的最多 只是内容的占位符 不会覆盖原有的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; html &#125;&#125;</span><br></pre></td></tr></table></figure><p>v-html 指令的作用 可以把带有标签的字符串 渲染成真正的HTML内容</p><h2 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h2><p>注意：插值表达式只能用在元素的内容节点中，不能用在元素的属性节点中！<br>v-bind 为元素的属性 动态绑定 指令可以简写成 :<br>如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号<br>v-on 绑定事件指令 用来为dom元素绑定事件监听 简写 @</p><p>在绑定事件处理函数的时候 可以使用小括号传参    </p><p>vue 提供了 内置对象 名字叫$event 他就是原生的事件对象e</p><p>v-model 双向数据绑定指令 用来辅助开发者在不操作dom的前端下 快速获取表单数据 </p><!-- input 输入框textareaselect --><h2 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h2><p>v-show 的原理是 动态为元素添加 或移除 display:none 样式 来实现元素的显示和隐藏</p><p>v-if 的原理是 每次动态创建或移除元素 实现元素的显示和移除</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>要定义到filters节点下 本质是一个函数<br>在过滤器函数中 一定要有 return值<br>在过滤器的形参中 就可以获取到 ‘管道符’ 前面待处理的那个值<br>如果全局过滤器和私有过滤器名字一致时 此时就按’就近原则’</p><h2 id="watch侦听器"><a href="#watch侦听器" class="headerlink" title="watch侦听器"></a>watch侦听器</h2><p>针对数据的变化 做特定的操作<br>方法格式的侦听器<br>缺点: 无法在刚进去页面的时候 自动触发<br>如果侦听的是一个对象 如果对象的属性发生了变化 不会触发 侦听器<br>对象格式的侦听器、<br>好处: 可以通过 immediate选项 让侦听器自动触发<br>深度侦听<br>可以通过deep选项 开启 深度监听 对象属性变化 也会触发 侦听器</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>通过一系列运算之后 最终得到一个属性值<br>定义要被定义方法<br>在使用计应属性时 当普通的属性使用即可<br>实现代码的复用<br>只要计算性中依赖的数据源的变化 则计算属性会自动重新求值</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios是一个专注 网络数据请求的数据库</p><h2 id="vue-cli的使用"><a href="#vue-cli的使用" class="headerlink" title="vue-cli的使用"></a>vue-cli的使用</h2><p>在终端下运行 vue create  项目</p><h2 id="vue的实例化"><a href="#vue的实例化" class="headerlink" title="vue的实例化"></a>vue的实例化</h2><pre><code>(1)、vue.js下载   cn.vuejs.org    并且引入vue.js (2)、创建根节点，并且取 id(3)、vue的实例化        var app = new Vue(&#123;        //选项        el:&quot;#app&quot; ,挂载的根节点的id值        data:&#123;&#125; ,数据项(对象)    &#125;);</code></pre><h2 id="vue的语法"><a href="#vue的语法" class="headerlink" title="vue的语法"></a>vue的语法</h2><pre><code>(1)、数据绑定    1)、&#123;&#123; 变量 &#125;&#125;  -&gt;将数据绑定到html,文本的原样输出绑定        &#123;&#123; js的表达式 &#125;&#125; -&gt;输出表达式的运算结果    2)、v-html=&quot;变量&quot;  -&gt;将数据保留html标签格式输出到html页面        &lt;div v-html=&quot;变量&quot;&gt;&lt;/div&gt;   将变量中的内容保留标签格式，插入到div标签中    3)、v-text=&quot;变量&quot; -&gt;将数据原样输出到html页面中        &lt;div v-text=&quot;变量&quot;&gt;&lt;/div&gt; 将数据原样输出到html页面中，插入到div标签中    4)、v-if=&quot;表达式&quot; -&gt;条件判断指令         &lt;div v-if=&quot;表达式&quot;&gt;&lt;/div&gt; 如果表达式成立，则输出显示div的内容                v-else-if=&quot;表达式&quot; -&gt;多分支条件语句                v-else  -&gt;与就近的v-if匹配使用，后面不带条件    5)、v-show=&quot;表达式&quot; -&gt;如果表达式成立，则显示相应的内容    如果表达式不成立，则显示相应的内容，但是是通过样式display:none 进行内容隐藏(html代码是存在页面上)    6)、v-once -&gt;只渲染一次，后续值再变，则html显示的结果不变        </code></pre><h2 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h2><pre><code>表达式1?表达式2:表达式3运算流程：判断表达式1是否成立，如果成立选择表达式2，否则选择表达式3</code></pre><h2 id="tab选项卡"><a href="#tab选项卡" class="headerlink" title="tab选项卡"></a>tab选项卡</h2><h3 id="使用vue，声明一个圆的半径值，页面上输出圆的面积与周长"><a href="#使用vue，声明一个圆的半径值，页面上输出圆的面积与周长" class="headerlink" title="使用vue，声明一个圆的半径值，页面上输出圆的面积与周长"></a>使用vue，声明一个圆的半径值，页面上输出圆的面积与周长</h3><h3 id="如果圆的面积大于100，则在页面上输出一个红色的圆，要求半径为12，"><a href="#如果圆的面积大于100，则在页面上输出一个红色的圆，要求半径为12，" class="headerlink" title="如果圆的面积大于100，则在页面上输出一个红色的圆，要求半径为12，"></a>如果圆的面积大于100，则在页面上输出一个红色的圆，要求半径为12，</h3><p>否则输入一个蓝色是正方形，要求边长为8</p><h2 id="指令-v-for-gt-循环指令-循环数据，生成列表"><a href="#指令-v-for-gt-循环指令-循环数据，生成列表" class="headerlink" title="指令 v-for  -&gt;循环指令(循环数据，生成列表)"></a>指令 v-for  -&gt;循环指令(循环数据，生成列表)</h2><pre><code>首先：先有数据数组或者对象(1)、结构1:      &lt;div v-for=&quot;value in object&quot;&gt;&lt;/div&gt;      注释：        object  -&gt;需要循环的数据对象数组        in -&gt;固定语法         value -&gt;逐次循环得到的元素值或者对象的属性值(2)、结构2：     &lt;div v-for=&quot;(val,key) in Object&quot;&gt;     &lt;/div&gt;     注释：        object  -&gt;需要循环的数据对象数组        in -&gt;固定语法         val -&gt;逐次循环得到的元素值或者对象的属性值        key -&gt;数组元素的下标或者是对象的属性的名称(3)、结构3：     &lt;div v-for=&quot;(val,key,index) in Object&quot;&gt;     &lt;/div&gt;     注释：        object  -&gt;需要循环的数据对象数组        in -&gt;固定语法         val -&gt;逐次循环得到的元素值或者对象的属性值        key -&gt; 数组元素的下标或者是对象的属性的名称        index -&gt; 属性的索引   如果循环的是数组，则无索引(4)、结构4：    &lt;div v-for=&quot;value in n&quot;&gt;&lt;/div&gt;     注释：        n  -&gt;需要循环的整数，从1开始循环，一直到N        in -&gt;固定语法         value -&gt;逐次循环得到的数            </code></pre><h2 id="什么数据可以循环？"><a href="#什么数据可以循环？" class="headerlink" title="什么数据可以循环？"></a>什么数据可以循环？</h2><pre><code>(1)、对象     var user = &#123;        username:&#39;小明&#39;,        sex:&#39;女&#39;,        age:&#39;23&#39;            &#125;        1)、对象符号为 花括号&#123;&#125;    2)、对象里面的叫做对象的成员        a)、属性 -&gt;属性名称和属性值        b)、方法    3)、获取对象的属性值： 对象.属性名    例如：user.username     4)、对象的属性有一个隐藏的信息，叫做索引，索引值从0开始(2)、数组    var arr = [&#39;小花&#39;,&#39;男&#39;,25];    1)、数组的符号是中括号[]    2)、数组由元素组成    3)、元素由 下标和元素值组成    4)、元素的下标从0开始    5)、获取数组的元素值     数组[下标]     arr[2]    (3)、整数的迭代(4)、对象数组：    数组里面的元素的值是对象        var list = [        &#123;title:&#39;今天你好帅啊&#39;,add_time:&#39;2000-10-10&#39;&#125;,        &#123;title:&#39;今天你好忙啊&#39;,add_time:&#39;2000-11-10&#39;&#125;,        &#123;title:&#39;今天你好凶啊&#39;,add_time:&#39;2000-12-10&#39;&#125;,    ];</code></pre><h2 id="弹性布局："><a href="#弹性布局：" class="headerlink" title="弹性布局："></a>弹性布局：</h2><pre><code>(1)、父级元素    1)、display:flex  -&gt;讲布局设为弹性布局    2)、justify-content -&gt;控制子级元素在主轴上的对齐方式        flex-start[默认值]  -&gt;主轴的开始方向对齐        flex-end  -&gt;主轴的结束方向对齐        center  -&gt;-&gt;主轴的中间方向对齐        space-between -&gt;主轴两端对齐，并且子元素与父元素无缝隙        space-around -&gt;主轴两端对齐，并且子元素与父元素有缝隙(子元素之间距离的1/2)    3)、flex-direction：控制主轴与交叉轴的方向         row[默认值] -&gt;主轴方向 从左到右边         row-reverse ：主轴方向 从右到左         column -&gt;主轴方向 从上到下         column-reverse; -&gt;主轴方向 从下到上    4)、flex-wrap -&gt;子元素是否换行          nowrap[默认值] -&gt;不换行         wrap  -&gt;换行         wrap-reverse -&gt;换行并且反向换行    5)、align-items -&gt;子元素在交叉轴的对齐方式(当子级元素只有一行式有效)        flex-start -&gt;在开始位置对齐        flex-end  -&gt;在结束位置对齐        center  -&gt;中间对齐        baseline -&gt; 控制子级元素的第一行文本的底端对齐。        stretch[默认值] -&gt; 如果子级元素没有设置高度，则平铺满父级元素    6)、align-content：子元素在交叉轴的对齐方式(当子级元素多行有效)             flex-start -&gt;开始方向对齐        flex-end  -&gt;结束方向对齐        center  -&gt;居中对齐        space-between -&gt;两端对齐，无缝隙        space-around -&gt;两端对齐，有缝隙 缝隙=子级元素的一半        stretch[默认值] -&gt;子级元素均匀分布，并且最后一行子级与父级有缝隙 缝隙=子级的间距(2)、子级元素     1)、order 属性定义子元素的排列顺序。数值越小，排列越靠前，默认为0     2)、flex-grow 属性定义子元素的放大比例，默认为0，即如果存在剩余空间，也不放大     3)、flex-shrink属性定义了子元素的缩小比例，默认为1，即如果空间不足，该项目将缩小。     4)、flex-basis -&gt;设置子级元素的固定宽度，不会受放大或者缩小影响     5)、align-self -&gt;单独控制子级元素在交叉轴的对齐方式        auto         flex-start         flex-end         center         baseline        stretch</code></pre><h2 id="指令：v-bind-给标签绑定属性"><a href="#指令：v-bind-给标签绑定属性" class="headerlink" title="指令：v-bind  给标签绑定属性"></a>指令：v-bind  给标签绑定属性</h2><pre><code>    结构：v-bind:属性名称=&quot;变量&quot;           简写 :属性名称=&quot;变量&quot;    注意：如果将标签的属性的值，通过vue写成一个变量，直接在标签的属性值中写变量，默认将变量当成字符串。    &lt;div id=&quot;app&quot;&gt;        &lt;a href=&quot;url&quot;&gt;搜一搜&lt;/a&gt;    &lt;/div&gt;        const app = new Vue(&#123;    el:&quot;#app&quot;,    data:&#123;                url:&#39;http://baidu.com&#39;    &#125;&#125;)href=&quot;url&quot;  并不会将url当成变量</code></pre><h2 id="用v-bind指令，绑定样式"><a href="#用v-bind指令，绑定样式" class="headerlink" title="用v-bind指令，绑定样式"></a>用v-bind指令，绑定样式</h2><pre><code>    (1)、给标签绑定类   :class=&quot;变量&quot;  例如： :class=&quot;lei&quot;   data:&#123; lei:&#39;red&#39;&#125;    注意： 变量必须在data里面声明，并且属性的值就是类的名称    (2)、如果是绑定多个类 :class=&quot;[变量1,变量2,...]&quot;    (3)、:class=&quot;&#123;类名:变量或表达式,类名:变量或表达式 &#125;&quot;  标签是否拥有这个类，如果表达式成立则有，否则无    (4)、行内式绑定样式  :style=&quot;&#123;样式名称:变量,样式名称:变量,样式名称:变量&#125;&quot;        注意：如果样式名称中带有-线，必须使用驼峰式，或者将样式名称使用单引号包着            background-color   backgroundColor  或者 &#39;background-color&#39;                    学号  姓名   语文  数学  英语     1001  小花    16    56    19    1002  小明     99   98     97                                                                            </code></pre><h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><pre><code>1、指令 v-on   给标签绑定事件 格式 v-on:事件名称 = &quot;js代码&quot;   简写成 @事件名称=&quot;js代码&quot;2、在vue中写函数(方法)    1)、给vue增加选项  methods:&#123;                            //方法(函数)                            //声明方法 方式1                            方法名称([参数])&#123;                                                                //方法的内容                                                            &#125;,                            //声明方法 方式2                            方法名称：function([参数])&#123;                                //方法的内容                                                            &#125;                        &#125;    2)、如何在vue的方法中修改数据项的数据值！        通过this指向当前vue的对象，从而找到相关的数据项        </code></pre><p>1、掌握相关的语法基础<br>2、运用相关的语法基础，将功能需求转化成程序逻辑！<br>3、vue的实例化，相关的选项<br>    (1)、el  -&gt;挂载点绑定<br>    (2)、data -&gt;数据项<br>    (3)、methods -&gt;方法<br>    (4)、computed -&gt;计算属性 (类似于方法)<br>    (5)、watch  -&gt;监听器 [监听数据项中的变量是否发生改变，如果发生改变，自动调用执行监听器]<br>    (6)、filters -&gt;过滤器 [值的转换工具(自定义的一个工具)]</p><pre><code>var app = new Vue(&#123;    //挂载点选项    el:&#39;#app&#39;,    //数据选项    data:&#123;            &#125;,    //方法选项    methods:&#123;        方法名称()&#123;            方法体        &#125;    &#125;,    //计算属性的选项    computed:&#123;        //声明一个计算属性        计算属性名称()&#123;                    &#125;            &#125;,    //监听器选项    watch:&#123;        变量名称(新值,旧值)&#123;                    &#125;            &#125;,    //过滤器     filters:&#123;        过滤器的名称(参数1,[参数2,参数3])&#123;            过滤器的功能        &#125;    &#125;    //注意 参数1，表示的是调用过滤器的变量！&#125;);调用计算属性  &#123;&#123;计算属性名称&#125;&#125;过滤器使用   &#123;&#123;变量|过滤器名称(参数)&#125;&#125;</code></pre><h2 id="数组-forEach-function-item-index"><a href="#数组-forEach-function-item-index" class="headerlink" title="数组.forEach(function(item,index){"></a>数组.forEach(function(item,index){</h2><pre><code>&#125;)</code></pre><p>   对数组进行循环遍历，有多少个元素，就会循环几次<br>     item对应数组的元素值，index对应数组元素的下标</p><p>过滤器实现：当变量字符串的长度超过n位时，保留n位字符串，后面加3个点</p><pre><code>    if(s.length&gt;n)&#123;        return s.slice(0,n)+&#39;...&#39;;    &#125;else&#123;        return s;    &#125;</code></pre><p>1、给标签绑定事件：<br>    v-on:事件 = “表达式”  v-on:事件 = “方法()”<br>    @事件 = “表达式”  @事件 = “方法()”<br>2、vue的选项<br>    (1)、el:”#app”  -&gt;绑定根节点<br>    (2)、data:{}  -&gt;数据项<br>    (3)、methods:{} -&gt;方法项<br>3、事件修饰符 -&gt;修饰事件，避免出现一些非正常化的情况！<br>    (1)、prevent 阻止提交 -&gt;一般用在表单提交上！<br>         表单会有提交事件 @submit.prevent 阻止表单提交<br>    (2)、stop 阻止冒泡<br>    (3)、self 表示发生在自身，而不是子级<br>    (4)、capture 捕获事件<br>4、表单的应用 -&gt;用户与服务器的数据交互的入口<br>    (1)、v-model -&gt;双向绑定，修改视图的数据，可以影响到vue的数据项的数据！修改数据项的数据值，同样会影响到视图的数据<br>    (2)、表单的元素<br>        1)、input [text|password|submit|email|number|tel|checkbox|radio|file|date]<br>        2)、下拉控件  select+option<br>        3)、文本域 textarea</p><p>5、表单修饰符<br>    1)、number   v-model.number = “变量”  -&gt;输入的变量为数字类型<br>    2)、v-model.lazy  -&gt;输入完成后<br>    3)、v-model.trim -&gt;去除前后空格</p><p>1、组件 - 提升代码复用，便于维护<br>    (1)、组件的声明 (将html代码块封装成一个自定义的标签)<br>        1)、局部组件 - 局部组件只能在挂载的父组件中使用！</p><pre><code>        创建组件vue选项         components:&#123;            &#39;组件名称&#39;:&#123;                //组件的选项                template:`组件的内容`,                data            &#125;        &#125;                注意：组件的命名，可以使用单引号，包含组件的名称，如果不使用单引号，则不允许使用中杠线。    2)、全局组件 - 全局组件，可以使用在所有的挂载组件中使用！            创建全局组件：            Vue.component(&#39;组件名称&#39;,&#123;                //组件的选项                template:`组件的内容`            &#125;);(2)、组件类似一个小vue，组件里面可以包含vue的所有选项.    1)、data选项，data选项必须是一个方法，不再是对象！        data()&#123;            return &#123;                //数据变量            &#125;        &#125;    2)、template内容选项        1)、template:`组件的内容`   -&gt;在封装组件式，将组件的内容全部写在 ``内部。        2)、template:&#39;#id的值&#39; -&gt;借用template标签，将组件的内容抽离到html页面             &lt;template id=&quot;值&quot;&gt;                组件的内容            &lt;/template&gt;        注意： 组件的内容，必须被一个根标签包着</code></pre><p>2、插槽 <slot></slot><br>    (1)、插槽的作用：将父组件的内容分发给子组件！<br>    (2)、插槽标签是写在组件上！<br>    (3)、俱名插槽  &lt;slot =”名称”&gt;</slot>   具有名称的插槽，内容分发时。指定将内容分发给哪一个插槽  &lt;开始标签 slot=”插槽的名称”&gt;&lt;/结束标签&gt; </p><p>3、组件的通信<br>    (1)、父组件给子组件传输数据！<br>         1)、在父组件调用子组件时，给子组件标签绑定一个自定义的属性，并且属性的值为父组件给子组件传输的数据变量<br>         2)、在子组件中，使用 props属性，接收父级组件传输过来的数据，数据的形参变量为父组件中自定义的属性的名称<br>            props:[‘自定义的属性名称’]<br>            在子组件中自定义的属性名称就可以作为一个变量，进行接收数据！<br>         3)、props 如果定义的是一个数组，则数组的元素就是接收到父级传输过来的属性的名称，里面存储了父级的数据<br>             props 如果是一个对象，对象的属性名称，就是接收父级传输过来的属性名称，属性值，指的是属性存储的值的类型。</p><pre><code>(2)、子组件给父组件传输数据            </code></pre><p>4、创建组件的流程：<br>    (1)、使用template标签，创建组件的模板 -&gt;模板必须有一个根节点<br>    (2)、确定需要创建的是局部组件还是全局组件！ (先有组件才进行挂载)<br>    (3)、创建组件的语法格式：<br>        1)、全局组件：<br>            Vue.component(‘组件的名称’,{<br>                template:”#id值”, //-&gt;组件模板<br>                //组件的数据项<br>                data(){<br>                    return {}<br>                },<br>                props:[‘父级自定义的属性名称’,…]   //接收父组件传输过来的数据</p><pre><code>        &#125;);    2)、局部组件         components：&#123;            &#39;组件的名称&#39;:&#123;            template:&quot;#id值&quot;, //-&gt;组件模板            //组件的数据项            data()&#123;                return &#123;&#125;             &#125;,            props:[&#39;父级自定义的属性名称&#39;,...]   //接收父组件传输过来的数据                        &#125;                    &#125;    </code></pre><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><pre><code>&lt;component is=&quot;组件的名称&quot;&gt;&lt;/component&gt;将哪一个组件的内容，嵌入到&lt;component&gt;&lt;/component&gt; 由属性is的值决定</code></pre><h2 id="作用域插槽-：从子组件向父组件传输数据"><a href="#作用域插槽-：从子组件向父组件传输数据" class="headerlink" title="作用域插槽 ：从子组件向父组件传输数据"></a>作用域插槽 ：从子组件向父组件传输数据</h2><pre><code>在调用子组件式，在组件标签内部，使用&lt;template scope=&quot;m&quot;&gt;&lt;/template&gt;   变量m就是一个对象，负责接收子组件中插槽标签的属性的值 ,在父组件中使用m.插槽的属性名称，即可获取到插槽属性的值。(通过将子组件中需要向父组件传输的数据，写在插槽标签的属性值上！)               </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue商城项目</title>
      <link href="/myblog/2023/01/09/Vue/Vue%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/"/>
      <url>/myblog/2023/01/09/Vue/Vue%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="目前还没打算写。"><a href="#目前还没打算写。" class="headerlink" title="目前还没打算写。"></a>目前还没打算写。</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/myblog/2023/01/09/hello-world/"/>
      <url>/myblog/2023/01/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
